Q1. Where are we instantiating instances of the Property class?
Inside console.rb when calling Property.new()

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
Inside property.rb under the save method definition
the variable 'sql' contains the sql code

Q3. In console.rb, which lines modify the database?
Property.delete_all and property1.save, property2.save

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
We don't define the id as it has not been added to the table yet. We may end up giving it an id that has already been taken.


Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
We assign the id generated by the database in property.rb with the save method.



Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
To make sure that it is not nil

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
the class methods are required as some methods are beyond the scope of an instance - such as calling for all rows within the database. We don't want to require an instance to be present if we want to delete everything from the database.  

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?


Q9. Why do we use prepared statements when performing database operations?
to protect ourselves from SQL injection attacks


Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
find by id takes in an integer
find by address takes in a string

Q11. What are their return values?
returns an array containing the corresponding properties of the found result
